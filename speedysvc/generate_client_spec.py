import json
from pathlib import Path
from typing import IO, Union
from inspect import Parameter, signature

from speedysvc.client_server.connect import connect


class MyExample:
    def blah(self, arg1, arg2, *arg, blah=None, **kw):
        return self._send_remote('blah', (arg1, arg2), arg, kw)


class SpeedySVCClient:
    def __init__(self,
                 address: str):

        self.__port_num = port_num
        self.__service_name = service_name
        self.__remote_host = remote_host

        connect(server_methods=self)



class SpeedySVCService:
    def __init__(self,
                 port_num: int,
                 service_name: str,
                 listen_on_interface: str = 'localhost'):

        self.__port_num = port_num
        self.__service_name = service_name
        self.__listen_on_interface = listen_on_interface

    def serve_forever(self):
        FIXME

    def save_client_boilerplate(self,
                                class_name: str,
                                path: Union[Path, str]):
        with open(path, 'w', encoding='utf-8') as f:
            f.write(self.format_client_boilerplate(class_name))

    def format_client_boilerplate(self, class_name: str):
        out = [
            f'''# NOTE: This file was auto-generated by SpeedySVCService, \n'''
            f'''#       and it's usually best not to modify it directly\n'''
            f'''from speedysvc.SpeedySVCClient import SpeedySVCClient\n'''
            f'''\n\n'''
            f'''class {class_name}(SpeedySVCClient):\n'''
            f'''    def __init__(self, port_num: int={json.dumps(self.__port_num)}, service_name: str={json.dumps(self.__service_name)}):\n'''
            f'''        SpeedySVCClient.__init__(self, port_num, service_name)\n'''
            f'''        \n'''
        ]
        for method_name in dir(self):
            out.append(self.__get_client_boilerplate(method_name))
        out.append('\n')
        out.append(f"""if __name__ == '__main__':\n""")
        out.append(f"""    {class_name}().serve_forever()\n""")
        return ''.join(out)

    def __get_client_boilerplate(self, method_name):
        method = getattr(self, method_name)

        if hasattr(method, 'serialised_params'):
            sig = signature(method)
            positional = []
            keyword = []
            var_positional = None
            var_keyword = None

            for param_name, param in sig.parameters.items():
                if param.kind == Parameter.POSITIONAL_ONLY:
                    positional.append(param.name)
                elif param.kind == Parameter.POSITIONAL_OR_KEYWORD:
                    positional.append(param.name)
                elif param.kind == Parameter.VAR_POSITIONAL:
                    var_positional = param.name
                elif param.kind == Parameter.KEYWORD_ONLY:
                    keyword.append(param.name)
                elif param.kind == Parameter.VAR_KEYWORD:
                    var_keyword = param.name
                else:
                    raise TypeError(f"Parameter type {param.kind} is unknown for {param.name}")

            if hasattr(method, '__doc__') and method.__doc__.strip():
                # Copy the docstring, if there is one
                doc = (
                    f'''        """''' +
                    method.__doc__ +
                    f'''"""\n'''
                )
            else:
                doc = ''

            if var_keyword and keyword:
                i = []
                for k in keyword:
                    i.append(
                        f'''        {var_keyword}[{json.dumps(k)}] = {k}\n'''
                    )
                return (
                        f'''   def {method_name}{str(sig)}:\n''' +
                        doc +
                        ''.join(i) +
                        f'''       return self._call_remote({json.dumps(method_name)},\n'''
                        f'''                                ({', '.join(positional)},)),\n'''
                        f'''                                {var_positional},\n'''
                        f'''                                {var_keyword})\n'''
                        f'''       \n'''
                )
            elif keyword:
                i = '''{%s}''' % ', '.join(f'{json.dumps(k)}: {k}' for k in keyword)
                return (
                    f'''    def {method_name}{str(sig)}:\n''' +
                    doc +
                    f'''        return self._call_remote({json.dumps(method_name)}, \n'''
                    f'''                                 ({', '.join(positional)},)),\n'''
                    f'''                                 {var_positional},\n'''
                    f'''                                 {i})\n'''
                    f'''        \n'''
                )
            else:
                # Keywords are expensive - just use ordinary params
                return (
                    f'''    def {method_name}{str(sig)}:\n''' +
                    doc +
                    f'''        return self._call_remote({json.dumps(method_name)}, \n'''
                    f'''                                 ({', '.join(positional)},)),\n'''
                    f'''                                 {var_positional},\n'''
                    f'''                                 {var_keyword})\n'''
                    f'''        \n'''
                )


def service_method(params='json', returns='json'):
    """
    Define a method which will be serialised using JSON types with
    a suitable encoder (e.g. the json module, msgpack, bson etc).
    """
    def return_fn(fn):
        fn.serialised_params = params
        fn.serialised_return = returns
        return fn
    return return_fn

