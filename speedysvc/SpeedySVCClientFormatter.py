import json
from pathlib import Path
from typing import Union, Optional
from inspect import Parameter, signature

from speedysvc.serialisation.RawSerialisation import RawSerialisation


FIND_TEXT = '# NOTE: This file was auto-generated by SpeedySVCService,'


class SpeedySVCClientFormatter:
    def __init__(self,
                 server_class,
                 port: int,
                 service_name: str,
                 client_imports: Optional[str] = None):

        self.server_class = server_class
        self.port = port
        self.service_name = service_name
        self.client_imports = client_imports

    def save_client_boilerplate(self,
                                class_name: str,
                                path: Union[Path, str],
                                check=True):

        if check and Path(path).exists() and FIND_TEXT in Path(path).read_text('utf-8', 'ignore'):
            raise Exception(f"Service client file {path} already exists without autogenerated header")

        with open(path, 'w', encoding='utf-8') as f:
            f.write(self.format_client_boilerplate(class_name))

    def format_client_boilerplate(self, class_name: str):
        out = [
            f'''# NOTE: This file was auto-generated by SpeedySVCService, \n'''
            f'''#       and it's usually best not to modify it directly\n'''
            f'''from speedysvc.SpeedySVCClient import SpeedySVCClient\n'''
            f'''{self.client_imports.strip() if self.client_imports else ''}'''
            f'''\n\n'''
            f'''class {class_name}(SpeedySVCClient):\n'''
            f'''    def __init__(self, port_num: int={json.dumps(self.port)}, service_name: str={json.dumps(self.service_name)}):\n'''
            f'''        SpeedySVCClient.__init__(self, port_num, service_name)\n'''
            f'''        \n'''
        ]
        for method_name in dir(self.server_class):
            if hasattr(getattr(self.server_class, method_name), 'metadata'):
                out.append(self.__get_client_boilerplate(method_name))
        out.append('\n')
        out.append(f"""if __name__ == '__main__':\n""")
        out.append(f"""    {class_name}().serve_forever()\n""")
        return ''.join(out)

    def __get_client_boilerplate(self, method_name):
        method = getattr(self.server_class, method_name)
        metadata = method.metadata

        if hasattr(method, 'serialised_params'):
            sig = signature(method)
            positional = []
            keyword = []
            var_positional = None
            var_keyword = None

            for param_name, param in sig.parameters.items():
                if param.kind == Parameter.POSITIONAL_ONLY:
                    positional.append(param.name)
                elif param.kind == Parameter.POSITIONAL_OR_KEYWORD:
                    positional.append(param.name)
                elif param.kind == Parameter.VAR_POSITIONAL:
                    var_positional = param.name
                elif param.kind == Parameter.KEYWORD_ONLY:
                    keyword.append(param.name)
                elif param.kind == Parameter.VAR_KEYWORD:
                    var_keyword = param.name
                else:
                    raise TypeError(f"Parameter type {param.kind} is unknown for {param.name}")

            if hasattr(method, '__doc__') and method.__doc__.strip():
                # Copy the docstring, if there is one
                doc = (
                    f'''        """''' +
                    method.__doc__ +
                    f'''"""\n'''
                )
            else:
                doc = ''

            # ct = call type (to allow reducing duplication while preserving indent below..)
            ct = 'call' if not metadata.returns_iterator else 'iter'

            if metadata.params_serialiser == RawSerialisation:
                # TODO: Add support for return type annotation etc
                return (
                        f'''   def {method_name}(data: bytes):\n''' +
                        doc +
                        f'''       return self._{ct}_remote_raw({method_name},\n'''
                        f'''                                    {json.dumps(method_name)},\n'''
                        f'''                                    data)\n'''
                        f'''       \n'''
                )
            elif var_keyword and keyword:
                i = []
                for k in keyword:
                    i.append(
                        f'''        {var_keyword}[{json.dumps(k)}] = {k}\n'''
                    )
                return (
                        f'''   def {method_name}{str(sig)}:\n''' +
                        doc +
                        ''.join(i) +
                        f'''       return self._{ct}_remote({method_name},\n'''
                        f'''                                {json.dumps(method_name)},\n'''
                        f'''                                ({', '.join(positional)},)),\n'''
                        f'''                                {var_positional},\n'''
                        f'''                                {var_keyword})\n'''
                        f'''       \n'''
                )
            elif keyword:
                i = '''{%s}''' % ', '.join(f'{json.dumps(k)}: {k}' for k in keyword)
                return (
                    f'''    def {method_name}{str(sig)}:\n''' +
                    doc +
                    f'''        return self._{ct}_remote({method_name},\n'''
                    f'''                                 {json.dumps(method_name)}, \n'''
                    f'''                                 ({', '.join(positional)},)),\n'''
                    f'''                                 {var_positional},\n'''
                    f'''                                 {i})\n'''
                    f'''        \n'''
                )
            else:
                # Keywords are expensive - just use ordinary params
                return (
                    f'''    def {method_name}{str(sig)}:\n''' +
                    doc +
                    f'''        return self._{ct}_remote({method_name},\n'''
                    f'''                                 {json.dumps(method_name)}, \n'''
                    f'''                                 ({', '.join(positional)},)),\n'''
                    f'''                                 {var_positional},\n'''
                    f'''                                 {var_keyword})\n'''
                    f'''        \n'''
                )
